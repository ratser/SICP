#lang r5rs
(#%require "error.rkt")
(#%require "table.rkt")
;;; separating syntactic analysis form execution

;;; table for installing syntactic analysis procedures of special forms
(define special-form-table (make-anyD-table))
(define (put-analyze tag proc)
  ((special-form-table 'insert!) (list tag) proc))
(define (get-analyze tag)
  ((special-form-table 'lookup) (list tag)))

;;; eval procedure, named my-eval to distinguish it
;;; from the build in eval procedure

;(define (my-eval exp env)
;  ((analyze exp) env))
(define (amb-eval exp env succeed fail)
  ((analyze exp) env succeed fail))

;;; analyze procedure
(define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((variable? exp)
         (analyze-variable exp))
        ((get-analyze (get-tag exp))
         ((get-analyze (get-tag exp)) exp))
        ((application? exp)
         (analyze-application exp))
        (else
         (error "Unknown expression type -- ANALYZE" exp))))

;;; syntactic analysis procedures

;(define (analyze-self-evaluating exp)
;  (lambda (env) exp))
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))

;(define (analyze-variable exp)
;  (lambda (env) (lookup-variable-value exp env)))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env) fail)))

;(define (analyze-quoted exp)
;  (let ((qval (text-of-quotation exp)))
;    (lambda (env) qval)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))

;(define (analyze-lambda exp)
;  (let ((vars (lambda-parameters exp))
;        (bproc (analyze-sequence (lambda-body exp))))
;    (lambda (env)
;      (make-procedure vars bproc env))))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env) fail))))

;(define (analyze-if exp)
;  (let ((pproc (analyze (if-predicate exp)))
;        (cproc (analyze (if-consequent exp)))
;        (aproc (analyze (if-alternative exp))))
;    (lambda (env)
;      (if (true? (pproc env))
;          (cproc env)
;          (aproc env)))))
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             fail))))

;(define (analyze-sequence exps)
;  (define (sequentially proc1 proc2)
;    (lambda (env) (proc1 env) (proc2 env)))
;  (define (loop first-proc rest-procs)
;    (if (null? rest-procs)
;        first-proc
;        (loop (sequentially first-proc
;                            (car rest-procs))
;              (cdr rest-procs))))
;  (let ((procs (map analyze exps)))
;    (if (null? procs)
;        (error "Empty sequence -- ANALYZE"))
;    (loop (car procs) (cdr procs))))
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env succeed fail)
      (proc1 env
             (lambda (proc1-value fail2)
               (proc2 env succeed fail2))
             fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc
                            (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))

;(define (analyze-definition exp)
;  (let ((var (definition-variable exp))
;        (vproc (analyze (definition-value exp))))
;    (lambda (env)
;      (define-variable! var (vproc env) env))))

(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))

;(define (analyze-assignment exp)
;  (let ((var (assignment-variable exp))
;        (vproc (analyze (assignment-value exp))))
;    (lambda (env)
;      (set-variable-value! var (vproc env) env))))
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (let ((old-value (lookup-variable-value var env)))
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()
                            (set-variable-value! var old-value env)
                            (fail2)))))
             fail))))

(define (analyze-begin exp)
  (analyze-sequence (begin-actions exp)))

(define (analyze-cond exp)
  (analyze (cond->if exp)))
(define (analyze-or exp)
  (analyze (or->if exp)))
(define (analyze-and exp)
  (analyze (and->if exp)))
(define (analyze-not exp)
  (analyze (not->if exp)))
(define (analyze-let exp)
  (analyze (let->combination exp)))
(define (analyze-let* exp)
  (analyze (let*->nested-lets exp)))
(define (analyze-letrec exp)
  (analyze (letrec->let exp)))

;(define (analyze-application exp)
;  (let ((fproc (analyze (operator exp)))
;        (aprocs (map analyze (operands exp))))
;    (lambda (env)
;      (execute-application (fproc env)
;                           (map (lambda (aproc) (aproc env))
;                                aprocs)))))
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) env
                    (lambda (arg fail2)
                      (get-args (cdr aprocs)
                                env
                                (lambda (args fail3)
                                  (succeed (cons arg args)
                                           fail3))
                                fail2))
                    fail)))

(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) env
                           succeed
                           (lambda ()
                             (try-next (cdr choices))))))
      (try-next cprocs))))

;;; execute-application procedure, which is analog of apply

;(define (execute-application proc args)
;  (cond ((primitive-procedure? proc)
;         (apply-primitive-procedure proc args))
;        ((compound-procedure? proc)
;         ((procedure-body proc)
;          (extend-environment
;           (procedure-parameters proc)
;           args
;           (procedure-environment proc))))
;        (else
;         (error "Unknown procedure type -- EXECUTE-APPLICATION" proc))))
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else
         (error "Unknown procedure type -- EXECUTE-APPLICATION" proc))))

;;; install syntactic procedures for special forms
(put-analyze 'if analyze-if)
(put-analyze 'set! analyze-assignment)
(put-analyze 'define analyze-definition)
(put-analyze 'quote analyze-quoted)
(put-analyze 'begin analyze-begin)
(put-analyze 'lambda analyze-lambda)
(put-analyze 'cond analyze-cond)
(put-analyze 'or analyze-or)
(put-analyze 'and analyze-and)
(put-analyze 'not analyze-not)
(put-analyze 'let analyze-let)
(put-analyze 'let* analyze-let*)
;(put-analyze 'make-unbound! analyze-make-unbound!)
(put-analyze 'letrec analyze-letrec)
(put-analyze 'amb analyze-amb)

;;; represent expressions
(define (get-tag exp) (car exp))
(define (self-evaluating? exp)
  (cond ((number? exp) #t)
        ((string? exp) #t)
        (else #f)))
(define (variable? exp)
  (symbol? exp))
(define (text-of-quotation exp)
  (cadr exp))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
(define (assignment-variable exp)
  (cadr exp))
(define (assignment-value exp)
  (caddr exp))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp) (cddr exp))))
(define (lambda-parameters exp)
  (cadr exp))
(define (lambda-body exp)
  (scan-out-defines (cddr exp)))
;;; scan out definitions in lambda body
(define (split seq f)
  (let ((exp (first-exp seq)))
    (if (last-exp? seq)
        (if (definition-exp? exp)
            (f seq '())
            (f '() seq))
        (if (definition-exp? exp)
            (split (rest-exps seq)
                   (lambda (defs other)
                     (f (cons exp defs) other)))
            (split (rest-exps seq)
                   (lambda (defs other)
                     (f defs (cons exp other))))))))
(define (definition-exp? exp)
  (tagged-list? 'define exp)) 
(define (make-new-body defs rest)
  (define (extract-vars defs)
    (map (lambda (exp) 
           (list (definition-variable exp) (make-quoted '*unassigned*)))
         defs))
  (define (extract-vals defs)
    (map (lambda (exp)
           (make-assignment (definition-variable exp) (definition-value exp)))
         defs))
  (if (null? defs)    ;if there is no definition in the body, just return the original body
      rest
      (list (make-let
             (extract-vars defs)
             (append (extract-vals defs) rest)))))     
(define (scan-out-defines seq)
  (split seq make-new-body))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
(define (begin-actions exp)
  (cdr exp))
(define (last-exp? seq)
  (null? (cdr seq)))
(define (first-exp seq)
  (car seq))
(define (rest-exps seq)
  (cdr seq))
(define (seq->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq)
  (cons 'begin seq))
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
(define (unbound-variable exp)
  (cadr exp))
;;; derived expressions
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause)
  (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond=>clause? clause)
  (eq? (cadr clause) '=>))
(define (cond-func clause)
  (caddr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (cond ((cond-else-clause? first)
               (if (null? rest)
                   (seq->exp (cond-actions first))
                   (error "ELSE clause isn't last -- COND->IF"
                          clauses)))
              ((cond=>clause? first)
               (make-if
                (cond-predicate first)
                (cons (cond-func first) 
                      (cons (cond-predicate first) '()))
                (expand-clauses rest)))
              (else (make-if
                     (cond-predicate first)
                     (seq->exp (cond-actions first))
                     (expand-clauses rest)))))))
(define (or-seq exp)
  (cdr exp))
(define (or->if exp)
  (expand-or (or-seq exp)))
(define (expand-or seq)
  (if (last-exp? seq)
      (first-exp seq)
      (make-if
       (first-exp seq)
       (first-exp seq)
       (expand-or (rest-exps seq)))))
(define (and-seq exp)
  (cdr exp))
(define (and->if exp)
  (expand-and (and-seq exp)))
(define (expand-and seq)
  (if (last-exp? seq)
      (first-exp seq)
      (make-if
       (first-exp seq)
       (expand-and (rest-exps seq))
       'false)))
(define (not-exp exp)
  (cadr exp))
(define (not->if exp)
  (make-if
   (not-exp exp)
   'false
   'true))
(define (let-variables exp)
  (map car (cadr exp)))
(define (let-exps exp)
  (map cadr (cadr exp)))
(define (let-body exp)
  (cddr exp))

(define (named-let? exp)
  (not (pair? (cadr exp))))
(define (let-name exp)
  (cadr exp))
(define (let-variables-named exp)
  (map car (caddr exp)))
(define (let-exps-named exp)
  (map cadr (caddr exp)))
(define (let-body-named exp)
  (cdddr exp))
(define (make-definition var exp)
  (list 'define var exp))

(define (let->combination exp)
  (if (named-let? exp)
      (cons
       (make-lambda (let-variables-named exp)
                    (cons
                     (make-definition
                      (let-name exp)
                      (make-lambda (let-variables-named exp)
                                   (let-body-named exp)))
                     (let-body-named exp)))
       (let-exps-named exp))
      (cons
       (make-lambda (let-variables exp)
                    (let-body exp))
       (let-exps exp))))

(define (make-let bindings body)
  (cons 'let (cons bindings body)))
(define (let*-bindings exp)
  (cadr exp))
(define (first-binding bindings)
  (list (car bindings)))
(define (rest-bindings bindings)
  (cdr bindings))
(define (last-binding? bindings)
  (null? (cdr bindings)))
(define (let*-body exp)
  (cddr exp))
(define (let*->nested-lets exp)
  (let*-expand (let*-bindings exp)
               (let*-body exp)))
(define (let*-expand bindings body)
  (if (last-binding? bindings)
      (make-let bindings body)
      (make-let (first-binding bindings)
                (list (let*-expand (rest-bindings bindings)
                             body)))))
;;; exercise 4.20
(define (letrec-variables exp)
  (map car (cadr exp)))
(define (letrec-exps exp)
  (map cadr (cadr exp)))
(define (letrec-body exp)
  (cddr exp))
(define (make-quoted x)
  (list 'quote x))
(define (make-assignment var val)
  (list 'set! var val))
(define (letrec->let exp)
  (define (make-let-var vars)
    (map (lambda (var)
           (list var (make-quoted 'unassigned)))
         vars))
  (define (make-let-body vars exps body)
    (append (map (lambda (var exp)
                   (make-assignment var exp))
                 vars exps)
            body))
  (make-let (make-let-var (letrec-variables exp))
            (make-let-body (letrec-variables exp)
                           (letrec-exps exp)
                           (letrec-body exp))))

(define (amb-choices exp) (cdr exp))

;;; Evaluator data structure ;;;
(define (true? x)
  (not (eq? x 'false)))
(define (false? x)
  (eq? x 'false))

(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (tagged-list? p tag)
  (if (pair? p)
      (eq? (car p) tag)
      #f))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))

;;; implement environment ;;;
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame)
  (car frame))
(define (frame-values frame)
  (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (error "The number of arguments and values is mismatched")))
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (if (eq? (car vals) '*unassigned*)
                 (error "Unassigned variable" var)
                 (car vals)))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))

;;;set up global environment with primitives;;;
(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true 'ture initial-env)
    (define-variable! 'false 'false initial-env)
    initial-env))

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
(define (bool-convert f)
  (lambda x
    (if (apply f x)
        'true
        'false)))
(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'list list)
        (list 'null? (bool-convert null?))
        (list 'pair? (bool-convert pair?))
        (list 'number? (bool-convert number?))
        (list 'symbol? (bool-convert symbol?))
        (list 'eq? (bool-convert eq?))
        (list 'equal? (bool-convert equal?))
        (list '= (bool-convert =))
        (list '> (bool-convert >))
        (list '< (bool-convert <))
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list 'remainder remainder)
        (list 'abs abs)))
(define (primitive-procedure-names)
  (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))
(define (apply-primitive-procedure proc args)
  (apply (primitive-implementation proc) args))

;;;prompt interface;;;
(define input-prompt "amb-eval input:")
(define output-prompt "amb-eval value:")
;(define (driver-loop)
;  (prompt-for-input input-prompt)
;  (let ((input (read)))
;    (let ((output (my-eval input the-global-environment)))
;      (announce-output output-prompt)
;      (user-print output)))
;  (driver-loop))
(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Starting a new problem ")
            (amb-eval input
                      the-global-environment
                      (lambda (val next-alternative)
                        (announce-output output-prompt)
                        (user-print val)
                        (internal-loop next-alternative))
                      (lambda ()
                        (announce-output
                         ";;; There are no more values of")
                        (user-print input)
                        (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; There is no current problem")
     (driver-loop))))
(define (prompt-for-input string)
  (newline)
  (display string)
  (newline))
(define (announce-output string)
  (newline)
  (display string)
  (newline))
(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

(define the-global-environment (setup-environment))
(driver-loop)

;(define (require p) (if (not p) (amb)))